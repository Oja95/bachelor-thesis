%!TEX root = ../thesis.tex
\documentclass[..thesis.tex]{subfiles}

\begin{document}

Honest Profiler is a software written in Java and C++ which aims to gather honest and accurate samples from a running Java application to provide an overview of the application's performance \cite{hon_prof}. Honest Profiler uses the \texttt{Async\-Get\-Call\-Trace} method for obtaining the samples. Moreover, Honest Profiler is licensed under an open source license which encourages the community to further investigate and develop this software solution. The fact that Honest Profiler is an open source software and utilizes a safepoint bias free method for obtaining the samples are the main reasons why this particular software is chosen for improvements and optimizations in this thesis.

\subsection{Architecture}
Honest Profiler cosists of two larger components: a JVMTI native agent and a Java facade for result visualization, analysis and transformation. The profiling is almost completely done by the agent whereas the Java facade component aims to provide tools to ease the use of the profiler.

The JVMTI agent is a dynamic library which serves as a client of the JVM Tooling Interface \cite{jvmtm}. JVMTI API provides these agents means to investigate and control the applications running on the Java Virtual Machine. Since the agents are written in native languages such as C and C++, they can also utilize various operating system's tools.

Honest Profiler relies on UNIX operating system signals and timers for obtaining samples.
It sets up a signal handler to handle \texttt{SIGPROF} signals sent to the Java process that the agent is attached to and an interval timer which sends the \texttt{SIGPROF} signal to that same process periodically. 

Upon receiving a signal, an \textit{arbitrary} thread currently executing on the CPU will handle the signal \cite{stevens_advanced_2013}. The signal handler proceeds to call \texttt{AsyncGetCallTrace} method from the JVMTI API to obtain the call trace of the current thread which is handling the signal. The obtained call trace is then persisted.

It is worth mentioning that the thread handling the \texttt{SIGPROF} signal can be any thread of the Java process being profiled. Even the threads responsible for garbage collection and just-in-time compilation. In such cases, the samples are discarded as such samples do not provide informative results. Samples which contain the observable application's stack frames are considered useful and provide relevant information about the application's performance.

%\supervisor{We currently hav a definition of useful sample in the future research section and we forward reference it from some point in next chapter. Maybe it would make sense to introduce this definitios somewhere here? Forward referencing to definition is not too nice and bringing in ``new'' definitions in future research does not seem ideal.}

\subsection{Current limitations}
Current implementation of Honest Profiler makes use of the standard interval timer from GNU time library and UNIX operating system signals to periodically call the \texttt{AsyncGetCallTrace} method. This implies that the lowest possible \texttt{Async\-Get\-Call\-Trace} method call interval is the time between two ticks of the system timer interrupt (\textit{jiffy}). This duration depends on the clock interrupt frequency of the hardware platform being used. Default clock frequency for Linux based operating systems (since kernel version 2.6.13) is 250 Hz which results in $\frac{1}{250} = 0.004$ seconds for the duration of a jiffy \cite{linux_time}. In such configuration, minimum sampling interval would be 4 milliseconds.


\subsection{\texttt{AsyncGetCallTrace} performance analysis}
Prior to increasing the sampling frequency, it is important to understand to what are the performance limitations that calling the \texttt{Async\-Get\-Call\-Trace} would imply. It is necessary to understand how long does a call to the \texttt{Async\-Get\-Call\-Trace} method take  to ensure that increasing the sampling frequency will not cause excessive performance overhead to the application being profiled. In order to measure the execution time, a custom Java Virtual Machine build with CPU time based time measurement logic was added to the \texttt{Async\-Get\-Call\-Trace} method. The added timing functionality is presented in Listing ~\ref{lst:asgct_time}.

\begin{lstlisting}[language=C++,style=def,label={lst:asgct_time}, caption={CPU time based measurement in \texttt{AsyncGetCallTrace} method}]
void AsyncGetCallTrace(ASGCT_CallTrace *trace, jint depth, void* ucontext) {
    struct timespec start, stop;
    clock_gettime(CLOCK_THREAD_CPUTIME_ID, &start);

    // AsyncGetCallTrace method code
    
    clock_gettime(CLOCK_THREAD_CPUTIME_ID, &stop);
    long accum = stop.tv_nsec - start.tv_nsec;
    printf("%li", accum);
}
\end{lstlisting}

Testing shows that a single \texttt{AsyncGetCallTrace} method call takes 4.6 microseconds on average.

\subsection{Implications of the performance analysis}
Previously described limitations and \texttt{Async\-Get\-Call\-Trace} method performance measurements do not expose apparent problems or reasons on why \texttt{Async\-Get\-Call\-Trace} method can not be called more frequently during profiling. As the \texttt{Async\-Get\-Call\-Trace} method execution time is significantly smaller when compared to the default lowest achieveable sampling interval, the hypothesis is that that having smaller profiling interval will not affect the observable application's performance to a great extent. Thus, achieving higher sampling frequency is a goal worth pursuing.

\end{document}
