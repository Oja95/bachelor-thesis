%!TEX root = ../thesis.tex
\documentclass[..thesis.tex]{subfiles}

\begin{document}

Honest Profiler \cite{hon_prof} is a software written in Java and C++ which aims to gather honest and accurate samples from a running Java application. It is one of the maturest profilers which utilizes the \texttt{AsyncGetCallTrace} method to obtain its samples. \supervisor{Is it one of the most maturest profilers, how do we measure maturity?} Moreover, Honest Profiler is licensed under an open source license which encourages the community to further investigate and develop this software solution.

\subsection{Architecture}
Honest Profiler cosists of two larger components: a JVMTI native agent and a Java facade for result visualization, analysis and transformation. The profiling is almost completely done by the agent whereas the Java facade component aims to provide tools to ease the use of the profiler.

\subsubsection{JVMTI agent}
\TODO{cite jvmti spec and/or doc}
JVMTI agent is a dynamic library which serves as a client of the JVM Tooling Interface. JVMTI provides these agents means to investigate and control the applications running on the Java Virtual Machine. Since the agents are written in native languages such as C and C++, they can also utilize various operating system's tools.

\TODO{Should describe how native agents work?}
\TODO{Signal handler setup and its handling mechanism (random thread)}
\TODO{Use of interval timer}
\TODO{Describe the usage of Lock-Free Single-Producer-Single Consumer Circular Queue in the signal handler for call trace persisting and why is it necessary due to limitations in signal handler. \url{https://www.codeproject.com/Articles/43510/Lock-Free-Single-Producer-Single-Consumer-Circular\#heading_references}}

\supervisor{This seems awfully detailed.}

\subsubsection{Java facade}
\TODO{Investigate and describe the tools in the Java facade}

\subsection{Current limitations}
\TODO{Citation needed for GNU time.}
\TODO{https://lwn.net/Articles/549593/ citate jiffy definition}
Current implementation of Honest Profiler makes use of the standard interval timer from GNU time library and UNIX operating system signals to periodically call the \texttt{AsyncGetCallTrace} method. This implies that the lowest \texttt{AsyncGetCallTrace} call interval is the time between two ticks of the system timer interrupt (\textit{jiffy}). This duration depends on the clock interrupt frequency of the hardware platform being used. Default clock frequency for Linux based operating systems (since kernel version 2.6.13) is 250 Hz which results in $\frac{1}{250} = 0.004$ seconds for the duration of a jiffy. \cite{linux_time} In such configuration, Honest Profiler would be able to obtain a sample every 4 milliseconds.

\TODO{Describe that the cpu time profiling is both a curse and a blessing due to only threads on CPU are getting profiled but the method is so cheap that we get more samples because of it}

% since the clock maintained by the kernel measures time in jiffies.

\subsection{\texttt{AsyncGetCallTrace} performance analysis}
\TODO{One of ASCGT pros is that it is incredibly cheap when compared to other profiling methods. Should find out how cheap it actually is. Needs brainstorming how to show its 'cheapness'}
\TODO{Actually build a custom OpenJDK and measure and persist the average execution time of ASGCT. Also figure out why is it useful. Maybe even deserves a separate section due to its extent}
\supervisor{Build the openJDK}}
\TODO{Describe what and why are being measured and how it is being measured}

\subsubsection{Java Microbenchmark Harness}
\TODO{Briefly describe jmh}

\subsubsection{Implications of the performance analysis}
\TODO{Consider splitting the perf analysis to separate section}
\TODO{Explain results}
\TODO{Show a graph}

\subsection{Optimizing the profiling implementation}
\TODO{Figure out a good topic for the kernel clock rate increase method.}
\subsubsection{Signal handling based on wall clock}
\TODO{Describe SIGALRM approach. Describe the additional bias it introduces.}
\supervisor{Does it really matter that it is SIGALRM? Maybe generalize it a bit and talk about possibilites of not relying on CPU time, for example we could send a signal ourselves if we wanted to.}

\end{document}
